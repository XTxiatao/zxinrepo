知识来源书籍：
  《代码整洁之道》
  《一线架构师实践指南》
  《代码大全》
  《领域驱动设计》
  《重构-改善既有代码的设计》
  《编写可读代码的艺术》
  
  
  
知识点：
  liunux共享内存shm
  微处理器指令架构
  编译原理
  操作系统原理
  计算机原理
  编码规范
  重构方法
  编码安全
  system()函数、syslog()函数
  C运算符：用法、结合律、优先级
  数据结构：循环链表、顺序表
  算法
  TDD
  虚拟化技术、容器
  shell和linux操作和常识
  多线程编程、异步安全函数
  多进程编程
  Linux进程通信方式
  C标准函数的未定义行为
  signal函数
  getenv()函数、setenv()函数
  可重入函数和调用
  字节序
  scanf函数格式化输入的取缓冲区的分界(s为空白符、%d为非数字)
  类型转换
  二级指针传参
  结构体灵活数组
  使用寄存器变量
  linux内核调度策略
  IP地址
  程序逆向分析的常用工具：nm、strings、addr2line、objdump
  gdb命令：backtrace、next、finish、continue、frame、info、jump、watch、break、catch、list、print
  内存布局与编译时/运行时状态
  文件操作函数
  C变量限制符：volatile
  bootrom程序
  linux共享内存shm通过<sys/shm.h>以及其他一些相关头文件引入调用，应用于多进程编程程序的内存共享，多线程编程不涉及。

使用任何变量前，必须对其进行声明，否则链接过程会报错标志符未定义；但是使用函数前没有进行声明，编译链接只会警告，可以成功编译运行

a / b ：a除以b 或者说是 a被b除  ，相反的b/a说法为 a 除 b。a除以b 也即 以b除a，简说为 b除a，以分子除分母。

free()只能对堆区的内存进行释放；数据区、栈区的大小在程序加载的时候就确定了，在程序结束的时候系统自动回收；堆区的内存在程序运行的过程中才由操作系统分配，这部分（物理）内存可以用free标记为不再使用，然后操作系统就会将其收回以供其他程序使用。但是数据区和栈区的内存不由人工申请，若用free来标记让操作系统回收，可能导致程序运行出错，所以free只能对堆区进行释放（标记）

C 中赋值类操作都是fun(target, source)的顺序，而shell中都是command  source  target的顺序

枚举类型直接当做一系列整形宏定义来使用就行，不必定义一个枚举类型以及使用枚举类型来定义变量。全局声明enum {Mon, Tues, Wed, Thur, Fri, Sart, Sund};在像宏一样使用即可

数组名作为函数参数会退化称指针，但是注意sizeof是预算符，其执行是在编译时完成的，所以几遍sizeof(arr)整体作为函数的参数，其结果也是arr数组大小而不是指针大小

全局变量、局部变量都不允许重复定义；局部变量生命周期到每轮循环结束，但是局部静态变量是特殊的，其生命周期是在整个程序期间，所以为了避免重复声明，函数或循环中的静态变量的声明语句只在第一次调用函数或者第一轮循环的时候生效。static只是把变量生命周期改变，并使得相同代码块只有第一次声明生效，函数只是代码块的一种情况。

while(i < 0){static int a = 0;}只在第一轮声明int a

while(i < 0){int a = 0;}每一轮都声明a，但是本轮声明的时候上轮的a生命已经结束，不会冲突

while(i < 0){static int a; static int a;}在第一轮声明两次产生冲突

fun(){static int a;while(i < 0){static int a}};  while(i < 0){fun();static int a;}四个静态声明都生效一次，且不冲突，其在对应层级作用域都只声明了一次静态变量；这是四个不同的静态变量。

= 优先级低于比较运算符，若要对赋值后的结果进行比较，一定要加括号，否则就成了用比较的结果进行赋值（即便是后者不需要加括号，也应该加括号显式表明表达式目的）

结构体灵活数组成员：在结构体成员的最后（不是最后会编译错误），声明一个不指定元素数量的数组。作用是将结构体变量后第一个可以存放数组类型的地址标记为该数组元素首地址，而且访问的时候也将其作为结构体成员，以.或者->方式访问。但是只将标志符与地址进行了关联，并没有获取改地址的访问权限。所以使用结构体灵活数组的时候只能将结构体变量声明为堆内存，通过申请所需大小的堆，确保数组成员的地址是有权限访问的。由于sizeof对于除了VLA以外的变量类型，都是编译时执行，所以sizeof包含灵活数组的结构体，数组不计算大小。虽然有结构体灵活数组成员的结构体一般用堆内存声明使用，但并不意味着在其他区使用就会报错。整个内存区都是可读的，所以通过灵活数组地址为基准读不会有问题；可写内存区声明的数组，只要偏移量不超出可写区范围，也是不会报错的。只读区声明的结构体灵活数组则地址在只读区，偏移量不到可写区，就会无权限写报错。

sizeof预算符在C99之前只在编译时执行，在C99引入边长数组VLA后，sizeof(VLA)是运行时执行。数组名在除了sizeof(arr)意外的所有场景都会退化成指针，而sizeof(expression)得到的是expression值的类型大小，这不需要通过计算就可以得到。定义int size = 9; int arr[num]; long b = 0; short a = 1;（就结论而言，虽然sizeof对VLA使用是运行时执行，但sizeof中的表达式永远无法产生副作用）

sizeof(arr) == 36 ，sizeof中的单一变量arr为VLA，运行时确定大小为36（不是单一变量的都用2-6的方法检验表达式类型）

sizoof(a + b) == 8 ，理解为c = a + b，根据类型提升原则，编译时得到表达式值类型为long，大小为8

sizeof(a = a + b) == 4，理解为c = a = a + b，c 的类型int，大小为4

sizeof(b = a + b) == 8，理解为c = b = a + b，c的类型long，大小为8

sizeof(a++ + ++b) == 8，表达式可理解为c = a++ + ++b；分成b = b + 1;c = a+b;a =a + 1; c 类型为long，大小为8

sizeof( a = arr) == 4，理解为 c = a = arr ，c的类型为int ，大小为4

const 限定符号可以理解为将const后的所有内容当做整体，这个整体的值不能改变，（）括起来方便记忆方法

const char *str  => const (char *str)字符串的值不能改变

char const *str  => char const (*str)字符串的值不能改变

char * const str => char * const (str) 指针的值不能改变

Linux虚拟内存地址分布：(只读区进行写操作一定报错，进行读可能报错；读写区进行读和写也都可能报错，但不一定报错）

内核地址在高位，所有进程看到的内核地址相同，内核地址空间是不可读写的。

内核区以下，首先是栈区。栈区的最高地址是程序运行开始就确定的。

栈区以下，是VLA数组的内存区，它紧接着栈区分布。它的顶部地址取决于本函数所有可能局部变量所占的内存加在一起的空间大小，因为VLA前有函数调用时函数调用结束其栈区使用结束，所以函数调用不会影响VLA上方应该预留的栈空间大小；无论子啊VLA之前还是之后声明的以及可能声明的局部变量，都会将VLA顶部地址向下推移，即便在if分支中不会被声明的变量，VLA计算顶部地址时也会算进去。但是实际上的栈不会给if分支不会声明的变量预留地址，所以当存在if分支中不被实际声明的变量时，VLA与栈底会空出if分支未声明变量需要的空间，当所以声明都被触发时，VLA与栈底时紧挨着分布的。VLA地址也可以在函数开始时就确定。

VLA以下是很长的未使用地址空间，然后是动态链接库的地址空间，然后又是一段未使用地址空间

未使用地址空间以下是堆区使用的地址空间。堆区从下向上延伸，每次分配堆变量都在原有堆空间上开始分配，堆空间的底部地址是程序执行开始时就确定的，它并不紧接着静态变量区分布。

全局静态变量区分为上部的可读写静态数据区和下部的只读静态数据区，只读的包括const限定的静态变量以及文本数据等，可读写的是一般的静态变量。无论声明变量的顺序如何，由于全局只读静态变量的空间是确定的（不能通过调用函数或分支声明全局变量），所以在程序开始时就可以就可以确保使即便后声明的可读写全局变量地址在只读全局静态变量的上方，且两个小区紧挨。

区局静态变量区下面是局部静态变量区（局部静态变量虽然也在静态区，但是可以在运行时才声明存在，所以其空间大小不确定，必须留有足够空间使用），两者不紧挨。

再往下为保留区

转义字符（合法转义字符不是全部字符，不包括一些控制字符）：在双引号或者单引号中的\为转义提示符，后面接被转移的字符，被转义的字符可以是排版类字符\n\t\v\f\b\r，用于移动光标位置，影响下一个字符输出的位置；\a发出警报响铃；\'\"\\\，‘’可以结束字符（在字符中必须转义输出），双引号可以结束字符串（在字符串中必须转义输出），\本身提示转义（在字符和字符转中都必须转义输出）；结束符\0，在字符和字符串中不加\都会被当做字符0输出，所以只能转义输出；\xhh和\ooo直接将对应16进制或8进制ASCII码转义为对应的字符输出（不写前缀是8进制，不存在10进制ASCII码转义），ASCII码可以是不足3位，转义优先最长可输出合法ASCII码转义，即若“\101”会被当做'e'字符而不是\n加1两个字符。当\转义提示符后检测到不合法转义字符为止，若一个合法转义输出字符都没有，则不产生任何输出。

格式化输入/输出：相比于其他输入/输出函数，格式化输入/输出函数（结尾带f的）的可选参数个数是不确定的，函数会根据format字符串中的格式控制符来寻找对应可选参数；可选参数可以一个都没有，但是format字符串参数必须有，所以当函数中只传入了一个字符串参数时，他会被当做format字符串参数而不是可选参数。只有format字符串参数中的%作为格式化控制符具有特殊意义会被解析（所以格式化字符串中要直接输出%需要以%%来实现），其他字符串的%都不具有特殊含义，不会被解析（直接输出）。format字符串参数是特殊的输出字符串，它本身具有输出字符串将\作为转义提示符的共性，还具有将%作为格式控制提示符的特性。格式化输入/输出函数的特有风险根本原因都是可选参数与格式控制符不匹配，包括直接将字符串变量作为唯一参数其中含有%的风险也是因为这个参数被当作format字符串参数，而其后有没有与%对应的可选参数。在格式化输入/输出函数的可选参数以及其他输入输出函数的参数中，%不会带来风险。

语法解析顺序和语句执行顺序：解析顺序有确定的C标准规定，比如运算符优先级和结合律，与编译器实现无关（必须符合标准）；语句执行分为两种操作类型，即计算和赋值，前者是将值在cpu中进行操作，存在寄存器中，后者是把寄存器中的值复制到指定内存中（即副作用），若一个语句或者子语句没有副作用，将不会被执行（结果不会保存，没有必要执行）。对于在两个规定结算点（必然进行副作用结算）之间，一个变量发生了多次副作用，由于副作用会将寄存器值存入内存，而计算会将内存中的值取入寄存器，在不知道副作用和计算的顺序的情况下，寄存器取到的值和内存存入的值都是不一定的，所以必须避免在两个结算点之间对一个值产生多次副作用，无论是直接赋值还是++/--的前缀/后缀赋值。在子表达式后存在结算点的有||和&&两个运算符，以及(  ,  )这里的逗号表达式是一个结算点。例如：

（i =2, i = i+1, i++, ++i）|| (i++, i = 2, ++i) && (i +=1, i++)中每一个i的值都是确定的

int i = 0; if ((i++ > 0);结果为假

int i = 0; if ((i++ > 0) || (i++ > 0))；结果为真，因为||前发生的副作用，导致第二个判断i的初值为1

以师带徒
练习和实战
数据结构：二叉树和散列相关的基本概念学习，以及常用的相关算法练习

合规学习
问题：
哪些情况需要申请许可/许可例外，对于黑名单国家/地区的不受管辖/受管辖/受管控出口是否都直接禁止，不用考虑申请许可？管控要素中的国家是只黑名单国家？若其他国家/地区都不涉及管控，那就只有这几个国家/地区有申请许可的需求，但是中兴合规政策直接禁止与该国的一切业务；只有对其他国家受限主体有批准后进行业务的说明，但是主体并不是管控的因素，应该也不作为需要许可的考虑因素把？

黑名单查询系统
LCM扫描
合规管控四要素包含主体、国家、物项和用途，公司接入GTS系统用于进行除了用途以外的三个因素的风险控制，保证主体、国家、物项不违反EAR管控要求。而LCM系统对接GTS，但只对合作伙伴进行主体扫描。主体扫描包含国家字段，但是只作为复查参考，不影响匹配结果。

GTS中的最终主体名称都是以英文字段存储和查询为准（模糊匹配），但是LCM系统中可以用中文和英文两种字符表示，系统自动对中文进行翻译，翻译结果可能不准确，以官方英文匹配结果为基准

主体扫描为真实命中时，要停止业务并进行相关申请核实后（若业务不在受控范围内）才能继续；模糊命中时视情况上报审核，再决定是否停止业务

查询和审核记录都要保存5年，查询结果的有效期为1个月

GTS扫描（只有ECC合规部有权限）
GTS是用于进出口行业服务的自动化系统，提供众多全球贸易信息服务。我司引入的合规管理服务模块，用于禁运国交易拦截、受限主体扫描以及EAR管控许可证管理，分别对应出口管制四要素中的目的地、主体和物项

GTS扫描数据库是LCM扫描的最终数据来源，LCM对接GTS

GTS本身除了英文主体清单，还有一些其他语言的主体清单可以扫描，包括中文。但是一次只能单独查询一种语言的清单，而LCM的中方合作伙伴查询经过翻译可以自动对接到GTS的两种语言系统，提高了效率，降低了漏检率

GTS不仅可以扫描美国政府相关的受限主体清单，还支持欧盟等世界主要经济体、联合国等的受限主体清单扫描

在签约和发货阶段都要进行GTS扫描，其中发货阶段涉及全部三类扫描（签约阶段没有物项？）

export.gov
美国官方黑名单查询系统，只有英文主体清单，只能查询美国政府的受限主体清单

EAR法律
黑名单国家和地区：伊朗、叙利亚、朝鲜、古巴、克里米亚。中兴合股政策 -> 黑名单国家与一般受经济制裁国家区别在于其作为一个整体受到制裁（因此也可以看出黑名单国家不是世界主要经济贸易国，比如俄罗斯不是黑名单国家），只要出口贸易涉及该地区以及出口贸易的主体属于该地区，都禁止交易，无论贸易发生地在哪里

EAR受控与否决定了出口交易是否需要申请许可或者许可例外，而是否EAR受控取决于两个因素：ECCN编码（物项）+  目的国/地区

C语言测试
要在函数内部改变外部指针的值，必须传入指针的指针，用过引用二级指针对一级指针赋值

printf函数的format和arguments原则：

遇到连续%%会打印%输出，不到arguments中寻找参数

遇到单一%会取arguments中找参数，若参数少于%个数，行为未定义；若参数多余%，多余的参数不被使用

%找到对应参数后，根据其后格式控制符决定行为，若格式控制符不存在或者错误或者与参数不匹配，结果未定义

%n是一个特殊的格式控制符，它与一个整形指针参数对应，将%n前的输出（不是format本身，而是stdout输出结果）的字符数，存储到指针指向的内存中。即若其他参数算作入参，%n对应的就是出参。同样的，当后面缺少对应参数时，行为未定义

strncpy, memcpy, snprintf三个函数都可以给字符数组赋值并限定赋值的长度，但是前两者赋值前都要注意给数组清零或者更高效的赋值后给添加一个结束符，而后者不需要手动添加结束符。当给定buffsize时，前两者会给目标赋值buffsize个字符，后者只赋值buffsize-1个字符，然后自动追加一个结束符

类型提升：在计算、赋值和比较运算时，都会进行类型提升。所有变量提升为最大变量类型再计算，其中类型大小关系为长字节大于短字节、无符号大于有符号、浮点型大于整形

字符串中查找字符，不需要用strlen先求长度，再用偏移不小于长度来作为终止条件。因strlen本身也是用每个字符与'\0'比较得到长度，直接在查找字符时把str[i] != '\0'作为判断条件更省事，性能更高。

定义数组类型别名的写法为typedef  char  str[20]，此时str的类型就是char[20]数组

C++中的引用传参方式，定义的形参的时候，用fun(type &var){}；形式定义，形参会自动对传入的实参取地址，并在函数内进行解引用。所以除了形参，传入参数以及函数定义内部，都是直接使用实参变量名对变量内容进行访问。

free结构体链表的场景中，每个结构体都是通过一个malloc堆内存分配得到的，而不是一个malloc得到的结构体数组（结构体数组也没必要通过指针来找了，直接随机访问就行）

#pragma pack（）预处理指令用于减小结构体对齐数。结构体对其数取决于成员变量的最大对齐数和系统对齐数的较小者，该预处理指令可以设置系统对齐数。当设置的对齐数大于成员最大对齐数时，对结构体对齐数没有影响，小于成员最大对齐数才可能影响最终结构体大小。pack（）括号里可以有四种指令，缺省值设置当前系统对齐数为默认对齐数；指定数字设定系统对齐数为指定对齐数；push ，n将n加入对齐数栈的栈顶，然后将栈顶数设定为当前系统对齐数；pop从栈顶弹出一个对齐数，然后将栈顶的对齐数设定为当前系统对齐数：push和pop之后的效果都是系统当前对齐数与栈顶对齐数一致。

Codewars
ASCII码对应十进制数字（关键位置）：'0'->48    ;'a'->97    ;'A'->65
